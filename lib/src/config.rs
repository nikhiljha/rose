//! Configuration and certificate management.
//!
//! Manages paths for certificates, known hosts, and authorized certs:
//! - `~/.config/rose/authorized_certs/` — client certs authorized to connect (server side)
//! - `~/.config/rose/known_hosts/` — TOFU server cert cache (client side)
//! - Client and server X.509 certificates generated by `rose keygen`

use std::path::{Path, PathBuf};
use std::sync::Arc;

use quinn::crypto::rustls::QuicClientConfig;
use rustls::SignatureScheme;
use rustls::pki_types::{CertificateDer, PrivateKeyDer, ServerName, UnixTime};
use serde::{Deserialize, Serialize};

/// Application configuration loaded from `~/.config/rose/config.toml`.
///
/// All fields have sensible defaults so a missing config file is equivalent
/// to an empty one.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(default)]
#[derive(Default)]
pub struct RoseConfig {
    /// Require CA-signed server certificates verified against the OS trust
    /// store. When `true`, TOFU and pinned self-signed certs are rejected.
    pub require_ca_certs: bool,

    /// Custom STUN server addresses for NAT traversal (e.g.,
    /// `["stun.example.com:3478"]`). When `None`, the built-in Google STUN
    /// servers are used.
    pub stun_servers: Option<Vec<String>>,
}

impl RoseConfig {
    /// Loads config from `<config_dir>/config.toml`, falling back to defaults
    /// if the file does not exist.
    ///
    /// # Errors
    ///
    /// Returns `ConfigError::Io` on filesystem errors or
    /// `ConfigError::ConfigParse` if the file is not valid TOML.
    pub fn load(config_dir: &Path) -> Result<Self, ConfigError> {
        let path = config_dir.join("config.toml");
        if !path.exists() {
            return Ok(Self::default());
        }
        let contents = std::fs::read_to_string(&path)?;
        toml::from_str(&contents).map_err(|e| ConfigError::ConfigParse(e.to_string()))
    }
}

/// Sanitizes a hostname for safe use in filesystem paths.
///
/// Replaces any character that is not alphanumeric, `.`, `-`, or `_` with `_`,
/// preventing path traversal attacks (e.g., `../../etc/passwd`).
#[must_use]
pub fn sanitize_hostname(host: &str) -> String {
    host.chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '.' || c == '-' || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect()
}

/// Errors that can occur during configuration or certificate operations.
#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    /// Certificate generation failed.
    #[error("certificate generation failed: {0}")]
    CertGen(#[from] rcgen::Error),
    /// TLS configuration error.
    #[error("TLS configuration error: {0}")]
    Tls(#[from] rustls::Error),
    /// I/O error (reading/writing cert files).
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    /// Quinn crypto configuration error.
    #[error("QUIC crypto configuration error: {0}")]
    QuicCrypto(String),
    /// Config file parse error.
    #[error("config parse error: {0}")]
    ConfigParse(String),
}

/// A generated certificate and its private key in both PEM and DER formats.
#[derive(Clone)]
pub struct CertKeyPair {
    /// PEM-encoded certificate.
    pub cert_pem: String,
    /// PEM-encoded private key.
    pub key_pem: String,
    /// DER-encoded certificate.
    pub cert_der: CertificateDer<'static>,
    /// DER-encoded private key.
    pub key_der: Vec<u8>,
}

/// Standard filesystem paths for `RoSE` configuration.
pub struct RosePaths {
    /// Root config directory (e.g. `~/.config/rose/`).
    pub config_dir: PathBuf,
    /// Directory for authorized client certs (server side).
    pub authorized_certs_dir: PathBuf,
    /// Directory for cached server certs (client side, TOFU).
    pub known_hosts_dir: PathBuf,
}

impl RosePaths {
    /// Resolves paths relative to the user's home directory.
    ///
    /// Uses `$HOME/.config/rose/` as the base.
    ///
    /// # Panics
    ///
    /// Panics if the `HOME` environment variable is not set.
    #[must_use]
    pub fn resolve() -> Self {
        let home = std::env::var("HOME").expect("HOME environment variable not set");
        Self::with_base(PathBuf::from(home).join(".config").join("rose"))
    }

    /// Constructs paths with an explicit base directory.
    #[must_use]
    pub fn with_base(base: PathBuf) -> Self {
        Self {
            authorized_certs_dir: base.join("authorized_certs"),
            known_hosts_dir: base.join("known_hosts"),
            config_dir: base,
        }
    }
}

/// Generates a self-signed X.509 certificate for the given Subject Alternative Names.
///
/// # Errors
///
/// Returns `ConfigError::CertGen` if certificate generation fails.
pub fn generate_self_signed_cert(san: &[String]) -> Result<CertKeyPair, ConfigError> {
    let certified_key = rcgen::generate_simple_self_signed(san.to_vec())?;
    let cert_pem = certified_key.cert.pem();
    let key_pem = certified_key.signing_key.serialize_pem();
    let cert_der = certified_key.cert.der().clone();
    let key_der = certified_key.signing_key.serialize_der();

    Ok(CertKeyPair {
        cert_pem,
        key_pem,
        cert_der,
        key_der,
    })
}

/// Result of a TOFU (Trust On First Use) certificate check.
#[derive(Debug, PartialEq, Eq)]
pub enum TofuResult {
    /// First time connecting to this host — cert was saved.
    FirstConnection,
    /// Cached cert matches the server's cert.
    Verified,
    /// Cached cert does NOT match — possible MITM attack.
    Mismatch {
        /// Path to the cached certificate that doesn't match.
        cached_path: PathBuf,
    },
}

/// Checks a server certificate against a TOFU known-hosts directory.
///
/// - If no cached cert exists for `host`, saves `server_cert_der` and returns `FirstConnection`.
/// - If the cached cert matches, returns `Verified`.
/// - If it differs, returns `Mismatch`.
///
/// # Errors
///
/// Returns `ConfigError::Io` if filesystem operations fail.
pub fn tofu_check(
    known_hosts_dir: &Path,
    host: &str,
    server_cert_der: &[u8],
) -> Result<TofuResult, ConfigError> {
    let sanitized = sanitize_hostname(host);
    let cert_path = known_hosts_dir.join(format!("{sanitized}.crt"));

    if cert_path.exists() {
        let cached = std::fs::read(&cert_path)?;
        if cached == server_cert_der {
            Ok(TofuResult::Verified)
        } else {
            Ok(TofuResult::Mismatch {
                cached_path: cert_path,
            })
        }
    } else {
        std::fs::create_dir_all(known_hosts_dir)?;
        std::fs::write(&cert_path, server_cert_der)?;
        Ok(TofuResult::FirstConnection)
    }
}

/// Computes the SHA-256 fingerprint of a DER-encoded certificate.
///
/// Returns a colon-separated hex string (e.g., `ab:cd:ef:...`).
#[must_use]
pub fn cert_fingerprint(cert_der: &[u8]) -> String {
    let hash = ring::digest::digest(&ring::digest::SHA256, cert_der);
    hash.as_ref()
        .iter()
        .map(|b| format!("{b:02x}"))
        .collect::<Vec<_>>()
        .join(":")
}

/// A server certificate verifier that checks the cert matches a pinned certificate.
///
/// Unlike root-store verification, this ignores Subject Alternative Names and
/// hostname checks — the security comes from the exact cert byte match, not
/// the certificate's claimed identity. TLS handshake signatures are still
/// verified cryptographically.
#[derive(Debug)]
struct PinnedCertVerifier {
    expected_cert: CertificateDer<'static>,
    provider: Arc<rustls::crypto::CryptoProvider>,
}

impl rustls::client::danger::ServerCertVerifier for PinnedCertVerifier {
    fn verify_server_cert(
        &self,
        end_entity: &CertificateDer<'_>,
        _intermediates: &[CertificateDer<'_>],
        _server_name: &ServerName<'_>,
        _ocsp_response: &[u8],
        _now: UnixTime,
    ) -> Result<rustls::client::danger::ServerCertVerified, rustls::Error> {
        if end_entity.as_ref() == self.expected_cert.as_ref() {
            Ok(rustls::client::danger::ServerCertVerified::assertion())
        } else {
            Err(rustls::Error::InvalidCertificate(
                rustls::CertificateError::ApplicationVerificationFailure,
            ))
        }
    }

    fn verify_tls12_signature(
        &self,
        message: &[u8],
        cert: &CertificateDer<'_>,
        dss: &rustls::DigitallySignedStruct,
    ) -> Result<rustls::client::danger::HandshakeSignatureValid, rustls::Error> {
        rustls::crypto::verify_tls12_signature(
            message,
            cert,
            dss,
            &self.provider.signature_verification_algorithms,
        )
    }

    fn verify_tls13_signature(
        &self,
        message: &[u8],
        cert: &CertificateDer<'_>,
        dss: &rustls::DigitallySignedStruct,
    ) -> Result<rustls::client::danger::HandshakeSignatureValid, rustls::Error> {
        rustls::crypto::verify_tls13_signature(
            message,
            cert,
            dss,
            &self.provider.signature_verification_algorithms,
        )
    }

    fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
        self.provider
            .signature_verification_algorithms
            .supported_schemes()
    }
}

/// A server certificate verifier that accepts any certificate identity but
/// still cryptographically verifies TLS handshake signatures.
///
/// Used for the TOFU first-connection flow: we don't know which cert to
/// expect, but we must verify the server actually holds the private key
/// for the cert it presents (otherwise a MITM could present an arbitrary
/// cert and the client would cache it permanently).
///
#[derive(Debug)]
struct TofuFirstConnectionVerifier {
    provider: Arc<rustls::crypto::CryptoProvider>,
}

impl rustls::client::danger::ServerCertVerifier for TofuFirstConnectionVerifier {
    fn verify_server_cert(
        &self,
        _end_entity: &CertificateDer<'_>,
        _intermediates: &[CertificateDer<'_>],
        _server_name: &ServerName<'_>,
        _ocsp_response: &[u8],
        _now: UnixTime,
    ) -> Result<rustls::client::danger::ServerCertVerified, rustls::Error> {
        Ok(rustls::client::danger::ServerCertVerified::assertion())
    }

    fn verify_tls12_signature(
        &self,
        message: &[u8],
        cert: &CertificateDer<'_>,
        dss: &rustls::DigitallySignedStruct,
    ) -> Result<rustls::client::danger::HandshakeSignatureValid, rustls::Error> {
        rustls::crypto::verify_tls12_signature(
            message,
            cert,
            dss,
            &self.provider.signature_verification_algorithms,
        )
    }

    fn verify_tls13_signature(
        &self,
        message: &[u8],
        cert: &CertificateDer<'_>,
        dss: &rustls::DigitallySignedStruct,
    ) -> Result<rustls::client::danger::HandshakeSignatureValid, rustls::Error> {
        rustls::crypto::verify_tls13_signature(
            message,
            cert,
            dss,
            &self.provider.signature_verification_algorithms,
        )
    }

    fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
        self.provider
            .signature_verification_algorithms
            .supported_schemes()
    }
}

/// Builds a quinn `ClientConfig` that verifies the server certificate against
/// the OS trust store and provides a client cert for mutual TLS.
///
/// Use this when `require_ca_certs` is `true` — the server must present a
/// CA-signed certificate (e.g., from Let's Encrypt).
///
/// # Errors
///
/// Returns `ConfigError` if the TLS configuration cannot be built.
pub fn build_platform_verified_client_config_with_cert(
    client_cert: &CertKeyPair,
) -> Result<quinn::ClientConfig, ConfigError> {
    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let verifier = rustls_platform_verifier::Verifier::new(Arc::clone(&provider))
        .map_err(|e| ConfigError::QuicCrypto(format!("platform verifier: {e}")))?;
    let rustls_config = rustls::ClientConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .dangerous()
        .with_custom_certificate_verifier(Arc::new(verifier))
        .with_client_auth_cert(
            vec![client_cert.cert_der.clone()],
            PrivateKeyDer::Pkcs8(client_cert.key_der.clone().into()),
        )?;

    let quic_client_config = QuicClientConfig::try_from(rustls_config)
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;

    let mut client_config = quinn::ClientConfig::new(Arc::new(quic_client_config));

    let mut transport = quinn::TransportConfig::default();
    transport.keep_alive_interval(Some(std::time::Duration::from_secs(5)));
    client_config.transport_config(Arc::new(transport));

    Ok(client_config)
}

/// Builds a quinn `ServerConfig` that requires mutual TLS client authentication.
///
/// Loads all `.crt` files from `authorized_certs_dir` as trusted client certificate
/// authorities.
///
/// # Errors
///
/// Returns `ConfigError` if any cert file is invalid or TLS configuration fails.
pub fn build_mutual_tls_server_config(
    cert: &CertKeyPair,
    authorized_certs_dir: &Path,
) -> Result<quinn::ServerConfig, ConfigError> {
    let mut root_store = rustls::RootCertStore::empty();

    if authorized_certs_dir.exists() {
        for entry in std::fs::read_dir(authorized_certs_dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.extension().is_some_and(|ext| ext == "crt") {
                let cert_data = std::fs::read(&path)?;
                let cert_der = CertificateDer::from(cert_data);
                root_store.add(cert_der)?;
            }
        }
    }

    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let client_verifier = rustls::server::WebPkiClientVerifier::builder_with_provider(
        Arc::new(root_store),
        Arc::clone(&provider),
    )
    .build()
    .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;
    let rustls_config = rustls::ServerConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .with_client_cert_verifier(client_verifier)
        .with_single_cert(
            vec![cert.cert_der.clone()],
            PrivateKeyDer::Pkcs8(cert.key_der.clone().into()),
        )?;

    let mut server_config = quinn::ServerConfig::with_crypto(Arc::new(
        quinn::crypto::rustls::QuicServerConfig::try_from(rustls_config)
            .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?,
    ));

    let mut transport = quinn::TransportConfig::default();
    transport.max_idle_timeout(Some(
        // 15s is well within the valid range for IdleTimeout.
        quinn::IdleTimeout::from(quinn::VarInt::from_u32(15_000)),
    ));
    server_config.transport_config(Arc::new(transport));

    Ok(server_config)
}

/// Builds a quinn `ClientConfig` that verifies a pinned server cert and provides
/// a client cert for mutual TLS.
///
/// Uses [`PinnedCertVerifier`] which checks exact cert byte equality, ignoring
/// SANs and hostname. This allows using real hostnames as `server_name` for SNI
/// while the security comes from the pinned cert match.
///
/// # Errors
///
/// Returns `ConfigError` if the TLS configuration cannot be built.
pub fn build_client_config_with_cert(
    server_cert_der: &CertificateDer<'static>,
    client_cert: &CertKeyPair,
) -> Result<quinn::ClientConfig, ConfigError> {
    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let verifier = PinnedCertVerifier {
        expected_cert: server_cert_der.clone(),
        provider: Arc::clone(&provider),
    };
    let rustls_config = rustls::ClientConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .dangerous()
        .with_custom_certificate_verifier(Arc::new(verifier))
        .with_client_auth_cert(
            vec![client_cert.cert_der.clone()],
            PrivateKeyDer::Pkcs8(client_cert.key_der.clone().into()),
        )?;

    let quic_client_config = QuicClientConfig::try_from(rustls_config)
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;

    let mut client_config = quinn::ClientConfig::new(Arc::new(quic_client_config));

    let mut transport = quinn::TransportConfig::default();
    transport.keep_alive_interval(Some(std::time::Duration::from_secs(5)));
    client_config.transport_config(Arc::new(transport));

    Ok(client_config)
}

/// Builds a quinn `ClientConfig` that accepts any server certificate and provides
/// a client cert for mutual TLS.
///
/// Used for the TOFU first-connection flow where the caller will extract the
/// server cert, prompt the user, and cache it for future verification.
///
/// # Errors
///
/// Returns `ConfigError` if the TLS configuration cannot be built.
pub fn build_tofu_client_config_with_cert(
    client_cert: &CertKeyPair,
) -> Result<quinn::ClientConfig, ConfigError> {
    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let verifier = TofuFirstConnectionVerifier {
        provider: Arc::clone(&provider),
    };
    let rustls_config = rustls::ClientConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .dangerous()
        .with_custom_certificate_verifier(Arc::new(verifier))
        .with_client_auth_cert(
            vec![client_cert.cert_der.clone()],
            PrivateKeyDer::Pkcs8(client_cert.key_der.clone().into()),
        )?;

    let quic_client_config = QuicClientConfig::try_from(rustls_config)
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;

    let mut client_config = quinn::ClientConfig::new(Arc::new(quic_client_config));

    let mut transport = quinn::TransportConfig::default();
    transport.keep_alive_interval(Some(std::time::Duration::from_secs(5)));
    client_config.transport_config(Arc::new(transport));

    Ok(client_config)
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    #[test]
    fn generate_cert_roundtrip() {
        let cert =
            generate_self_signed_cert(&["localhost".to_string(), "127.0.0.1".to_string()]).unwrap();

        assert!(!cert.cert_pem.is_empty());
        assert!(!cert.key_pem.is_empty());
        assert!(!cert.cert_der.is_empty());
        assert!(!cert.key_der.is_empty());
        assert!(cert.cert_pem.contains("BEGIN CERTIFICATE"));
        assert!(cert.key_pem.contains("BEGIN PRIVATE KEY"));
    }

    #[test]
    fn paths_resolve() {
        let paths = RosePaths::resolve();
        assert!(paths.config_dir.ends_with("rose"));
        assert!(paths.authorized_certs_dir.ends_with("authorized_certs"));
        assert!(paths.known_hosts_dir.ends_with("known_hosts"));
    }

    #[test]
    fn tofu_first_connection_saves_cert() {
        let dir = std::env::temp_dir().join(format!("rose-tofu-test-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);

        let cert_data = b"fake-cert-der-data";
        let result = tofu_check(&dir, "example.com", cert_data).unwrap();
        assert_eq!(result, TofuResult::FirstConnection);

        // Cert file should exist now
        let cert_path = dir.join("example.com.crt");
        assert!(cert_path.exists());
        assert_eq!(std::fs::read(&cert_path).unwrap(), cert_data);

        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn tofu_verified_on_matching_cert() {
        let dir = std::env::temp_dir().join(format!("rose-tofu-verify-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);

        let cert_data = b"matching-cert";
        // First connection saves it
        tofu_check(&dir, "host1", cert_data).unwrap();
        // Second connection verifies it
        let result = tofu_check(&dir, "host1", cert_data).unwrap();
        assert_eq!(result, TofuResult::Verified);

        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn tofu_mismatch_on_changed_cert() {
        let dir = std::env::temp_dir().join(format!("rose-tofu-mismatch-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);

        let cert_v1 = b"original-cert";
        let cert_v2 = b"changed-cert";
        tofu_check(&dir, "host2", cert_v1).unwrap();
        let result = tofu_check(&dir, "host2", cert_v2).unwrap();
        assert_eq!(
            result,
            TofuResult::Mismatch {
                cached_path: dir.join("host2.crt"),
            }
        );

        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn sanitize_hostname_normal() {
        assert_eq!(sanitize_hostname("example.com"), "example.com");
        assert_eq!(sanitize_hostname("host-1_a"), "host-1_a");
    }

    #[test]
    fn sanitize_hostname_path_traversal() {
        assert_eq!(sanitize_hostname("../../etc/passwd"), ".._.._etc_passwd");
        assert_eq!(sanitize_hostname("foo/bar"), "foo_bar");
    }

    #[test]
    fn tofu_path_traversal_is_contained() {
        let dir = std::env::temp_dir().join(format!("rose-tofu-traversal-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);

        let result = tofu_check(&dir, "../../etc/shadow", b"cert").unwrap();
        assert_eq!(result, TofuResult::FirstConnection);
        assert!(dir.join(".._.._etc_shadow.crt").exists());

        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn paths_with_base() {
        let paths = RosePaths::with_base(PathBuf::from("/tmp/rose-test"));
        assert_eq!(paths.config_dir, PathBuf::from("/tmp/rose-test"));
        assert_eq!(
            paths.authorized_certs_dir,
            PathBuf::from("/tmp/rose-test/authorized_certs")
        );
        assert_eq!(
            paths.known_hosts_dir,
            PathBuf::from("/tmp/rose-test/known_hosts")
        );
    }

    #[test]
    fn cert_fingerprint_format() {
        let data = b"test cert data";
        let fp = cert_fingerprint(data);
        assert!(fp.contains(':'));
        let parts: Vec<&str> = fp.split(':').collect();
        assert_eq!(parts.len(), 32);
        for part in &parts {
            assert_eq!(part.len(), 2);
            assert!(part.chars().all(|c| c.is_ascii_hexdigit()));
        }
    }

    #[test]
    fn cert_fingerprint_deterministic() {
        let data = b"same input";
        assert_eq!(cert_fingerprint(data), cert_fingerprint(data));
    }

    #[test]
    fn cert_fingerprint_different_for_different_input() {
        assert_ne!(cert_fingerprint(b"cert-a"), cert_fingerprint(b"cert-b"));
    }

    #[test]
    fn build_client_config_with_cert_succeeds() {
        let server = generate_self_signed_cert(&["localhost".to_string()]).unwrap();
        let client = generate_self_signed_cert(&["localhost".to_string()]).unwrap();
        let config = build_client_config_with_cert(&server.cert_der, &client);
        assert!(config.is_ok());
    }

    #[test]
    fn build_tofu_client_config_with_cert_succeeds() {
        let client = generate_self_signed_cert(&["localhost".to_string()]).unwrap();
        let config = build_tofu_client_config_with_cert(&client);
        assert!(config.is_ok());
    }

    #[test]
    fn build_platform_verified_client_config_with_cert_succeeds() {
        let client = generate_self_signed_cert(&["localhost".to_string()]).unwrap();
        let config = build_platform_verified_client_config_with_cert(&client);
        assert!(config.is_ok());
    }

    #[test]
    fn config_default_does_not_require_ca() {
        let cfg = RoseConfig::default();
        assert!(!cfg.require_ca_certs);
    }

    #[test]
    fn config_load_missing_file_returns_default() {
        let dir = std::env::temp_dir().join(format!("rose-cfg-missing-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);
        let cfg = RoseConfig::load(&dir).unwrap();
        assert_eq!(cfg, RoseConfig::default());
    }

    #[test]
    fn config_load_empty_file_returns_default() {
        let dir = std::env::temp_dir().join(format!("rose-cfg-empty-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);
        std::fs::create_dir_all(&dir).unwrap();
        std::fs::write(dir.join("config.toml"), "").unwrap();
        let cfg = RoseConfig::load(&dir).unwrap();
        assert_eq!(cfg, RoseConfig::default());
        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn config_load_require_ca_certs_true() {
        let dir = std::env::temp_dir().join(format!("rose-cfg-ca-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);
        std::fs::create_dir_all(&dir).unwrap();
        std::fs::write(dir.join("config.toml"), "require_ca_certs = true\n").unwrap();
        let cfg = RoseConfig::load(&dir).unwrap();
        assert!(cfg.require_ca_certs);
        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn config_load_invalid_toml() {
        let dir = std::env::temp_dir().join(format!("rose-cfg-bad-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);
        std::fs::create_dir_all(&dir).unwrap();
        std::fs::write(dir.join("config.toml"), "not valid {{{{ toml").unwrap();
        let err = RoseConfig::load(&dir).unwrap_err();
        assert!(matches!(err, ConfigError::ConfigParse(_)));
        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn config_roundtrip_toml() {
        let cfg = RoseConfig {
            require_ca_certs: true,
            stun_servers: Some(vec![
                "stun.example.com:3478".to_string(),
                "stun2.example.com:3478".to_string(),
            ]),
        };
        let serialized = toml::to_string(&cfg).unwrap();
        let deserialized: RoseConfig = toml::from_str(&serialized).unwrap();
        assert_eq!(cfg, deserialized);
    }

    #[test]
    fn config_load_stun_servers() {
        let dir = std::env::temp_dir().join(format!("rose-cfg-stun-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);
        std::fs::create_dir_all(&dir).unwrap();
        std::fs::write(
            dir.join("config.toml"),
            "stun_servers = [\"stun.example.com:3478\"]\n",
        )
        .unwrap();
        let cfg = RoseConfig::load(&dir).unwrap();
        assert_eq!(
            cfg.stun_servers,
            Some(vec!["stun.example.com:3478".to_string()])
        );
        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn config_default_stun_servers_is_none() {
        let cfg = RoseConfig::default();
        assert!(cfg.stun_servers.is_none());
    }
}
