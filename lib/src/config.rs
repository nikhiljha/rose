//! Configuration and certificate management.
//!
//! Manages paths for certificates, known hosts, and authorized certs:
//! - `~/.config/rose/authorized_certs/` — client certs authorized to connect (server side)
//! - `~/.config/rose/known_hosts/` — TOFU server cert cache (client side)
//! - Client and server X.509 certificates generated by `rose keygen`

use std::path::{Path, PathBuf};
use std::sync::Arc;

use quinn::crypto::rustls::QuicClientConfig;
use rustls::SignatureScheme;
use rustls::pki_types::{CertificateDer, PrivateKeyDer, ServerName, UnixTime};

/// Errors that can occur during configuration or certificate operations.
#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    /// Certificate generation failed.
    #[error("certificate generation failed: {0}")]
    CertGen(#[from] rcgen::Error),
    /// TLS configuration error.
    #[error("TLS configuration error: {0}")]
    Tls(#[from] rustls::Error),
    /// I/O error (reading/writing cert files).
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    /// Quinn crypto configuration error.
    #[error("QUIC crypto configuration error: {0}")]
    QuicCrypto(String),
}

/// A generated certificate and its private key in both PEM and DER formats.
pub struct CertKeyPair {
    /// PEM-encoded certificate.
    pub cert_pem: String,
    /// PEM-encoded private key.
    pub key_pem: String,
    /// DER-encoded certificate.
    pub cert_der: CertificateDer<'static>,
    /// DER-encoded private key.
    pub key_der: Vec<u8>,
}

/// Standard filesystem paths for `RoSE` configuration.
pub struct RosePaths {
    /// Root config directory (e.g. `~/.config/rose/`).
    pub config_dir: PathBuf,
    /// Directory for authorized client certs (server side).
    pub authorized_certs_dir: PathBuf,
    /// Directory for cached server certs (client side, TOFU).
    pub known_hosts_dir: PathBuf,
}

impl RosePaths {
    /// Resolves paths relative to the user's home directory.
    ///
    /// Uses `$HOME/.config/rose/` as the base.
    ///
    /// # Panics
    ///
    /// Panics if the `HOME` environment variable is not set.
    #[must_use]
    pub fn resolve() -> Self {
        let home = std::env::var("HOME").expect("HOME environment variable not set");
        Self::with_base(PathBuf::from(home).join(".config").join("rose"))
    }

    /// Constructs paths with an explicit base directory.
    #[must_use]
    pub fn with_base(base: PathBuf) -> Self {
        Self {
            authorized_certs_dir: base.join("authorized_certs"),
            known_hosts_dir: base.join("known_hosts"),
            config_dir: base,
        }
    }
}

/// Generates a self-signed X.509 certificate for the given Subject Alternative Names.
///
/// # Errors
///
/// Returns `ConfigError::CertGen` if certificate generation fails.
pub fn generate_self_signed_cert(san: &[String]) -> Result<CertKeyPair, ConfigError> {
    let certified_key = rcgen::generate_simple_self_signed(san.to_vec())?;
    let cert_pem = certified_key.cert.pem();
    let key_pem = certified_key.signing_key.serialize_pem();
    let cert_der = certified_key.cert.der().clone();
    let key_der = certified_key.signing_key.serialize_der();

    Ok(CertKeyPair {
        cert_pem,
        key_pem,
        cert_der,
        key_der,
    })
}

/// Builds a quinn `ServerConfig` from a certificate and private key.
///
/// Datagrams are enabled by default in the transport config (quinn default).
///
/// # Errors
///
/// Returns `ConfigError::Tls` if the TLS configuration is invalid.
pub fn build_server_config(cert: &CertKeyPair) -> Result<quinn::ServerConfig, ConfigError> {
    let server_config = quinn::ServerConfig::with_single_cert(
        vec![cert.cert_der.clone()],
        PrivateKeyDer::Pkcs8(cert.key_der.clone().into()),
    )?;
    Ok(server_config)
}

/// Builds a quinn `ClientConfig` that trusts a specific server certificate.
///
/// This is used for the TOFU/pinned-cert model where the client knows the
/// server's certificate in advance.
///
/// # Errors
///
/// Returns `ConfigError` if the TLS configuration cannot be built.
pub fn build_client_config(
    server_cert_der: &CertificateDer<'static>,
) -> Result<quinn::ClientConfig, ConfigError> {
    let mut root_store = rustls::RootCertStore::empty();
    root_store.add(server_cert_der.clone())?;

    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let rustls_config = rustls::ClientConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .with_root_certificates(root_store)
        .with_no_client_auth();

    let quic_client_config = QuicClientConfig::try_from(rustls_config)
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;

    let mut client_config = quinn::ClientConfig::new(Arc::new(quic_client_config));

    // Use the same transport config defaults (datagrams enabled)
    let mut transport = quinn::TransportConfig::default();
    transport.keep_alive_interval(Some(std::time::Duration::from_secs(5)));
    client_config.transport_config(Arc::new(transport));

    Ok(client_config)
}

/// Result of a TOFU (Trust On First Use) certificate check.
#[derive(Debug, PartialEq, Eq)]
pub enum TofuResult {
    /// First time connecting to this host — cert was saved.
    FirstConnection,
    /// Cached cert matches the server's cert.
    Verified,
    /// Cached cert does NOT match — possible MITM attack.
    Mismatch {
        /// Path to the cached certificate that doesn't match.
        cached_path: PathBuf,
    },
}

/// Checks a server certificate against a TOFU known-hosts directory.
///
/// - If no cached cert exists for `host`, saves `server_cert_der` and returns `FirstConnection`.
/// - If the cached cert matches, returns `Verified`.
/// - If it differs, returns `Mismatch`.
///
/// # Errors
///
/// Returns `ConfigError::Io` if filesystem operations fail.
pub fn tofu_check(
    known_hosts_dir: &Path,
    host: &str,
    server_cert_der: &[u8],
) -> Result<TofuResult, ConfigError> {
    let cert_path = known_hosts_dir.join(format!("{host}.crt"));

    if cert_path.exists() {
        let cached = std::fs::read(&cert_path)?;
        if cached == server_cert_der {
            Ok(TofuResult::Verified)
        } else {
            Ok(TofuResult::Mismatch {
                cached_path: cert_path,
            })
        }
    } else {
        std::fs::create_dir_all(known_hosts_dir)?;
        std::fs::write(&cert_path, server_cert_der)?;
        Ok(TofuResult::FirstConnection)
    }
}

/// A server certificate verifier that accepts any certificate.
///
/// This is intentionally insecure and should only be used for the TOFU
/// first-connection flow where the cert is then cached for future verification.
#[derive(Debug)]
struct TofuFirstConnectionVerifier;

impl rustls::client::danger::ServerCertVerifier for TofuFirstConnectionVerifier {
    fn verify_server_cert(
        &self,
        _end_entity: &CertificateDer<'_>,
        _intermediates: &[CertificateDer<'_>],
        _server_name: &ServerName<'_>,
        _ocsp_response: &[u8],
        _now: UnixTime,
    ) -> Result<rustls::client::danger::ServerCertVerified, rustls::Error> {
        Ok(rustls::client::danger::ServerCertVerified::assertion())
    }

    fn verify_tls12_signature(
        &self,
        _message: &[u8],
        _cert: &CertificateDer<'_>,
        _dss: &rustls::DigitallySignedStruct,
    ) -> Result<rustls::client::danger::HandshakeSignatureValid, rustls::Error> {
        Ok(rustls::client::danger::HandshakeSignatureValid::assertion())
    }

    fn verify_tls13_signature(
        &self,
        _message: &[u8],
        _cert: &CertificateDer<'_>,
        _dss: &rustls::DigitallySignedStruct,
    ) -> Result<rustls::client::danger::HandshakeSignatureValid, rustls::Error> {
        Ok(rustls::client::danger::HandshakeSignatureValid::assertion())
    }

    fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
        rustls::crypto::ring::default_provider()
            .signature_verification_algorithms
            .supported_schemes()
    }
}

/// Builds a quinn `ClientConfig` that accepts any server certificate (TOFU first connection).
///
/// After connecting, the caller should extract the server cert from the connection
/// and pass it to [`tofu_check`] to save it.
///
/// # Errors
///
/// Returns `ConfigError` if the TLS configuration cannot be built.
pub fn build_tofu_client_config() -> Result<quinn::ClientConfig, ConfigError> {
    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let rustls_config = rustls::ClientConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .dangerous()
        .with_custom_certificate_verifier(Arc::new(TofuFirstConnectionVerifier))
        .with_no_client_auth();

    let quic_client_config = QuicClientConfig::try_from(rustls_config)
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;

    let mut client_config = quinn::ClientConfig::new(Arc::new(quic_client_config));

    let mut transport = quinn::TransportConfig::default();
    transport.keep_alive_interval(Some(std::time::Duration::from_secs(5)));
    client_config.transport_config(Arc::new(transport));

    Ok(client_config)
}

/// Builds a quinn `ClientConfig` that verifies the server certificate against the
/// OS platform trust store (system CA certificates).
///
/// Use this for servers with CA-signed certificates (e.g., from Let's Encrypt).
/// Falls back to TOFU if the platform verifier is unavailable.
///
/// # Errors
///
/// Returns `ConfigError` if the TLS configuration cannot be built.
pub fn build_platform_verified_client_config() -> Result<quinn::ClientConfig, ConfigError> {
    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let verifier = rustls_platform_verifier::Verifier::new(Arc::clone(&provider))
        .map_err(|e| ConfigError::QuicCrypto(format!("platform verifier: {e}")))?;
    let rustls_config = rustls::ClientConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .dangerous()
        .with_custom_certificate_verifier(Arc::new(verifier))
        .with_no_client_auth();

    let quic_client_config = QuicClientConfig::try_from(rustls_config)
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;

    let mut client_config = quinn::ClientConfig::new(Arc::new(quic_client_config));

    let mut transport = quinn::TransportConfig::default();
    transport.keep_alive_interval(Some(std::time::Duration::from_secs(5)));
    client_config.transport_config(Arc::new(transport));

    Ok(client_config)
}

/// Builds a quinn `ServerConfig` that requires mutual TLS client authentication.
///
/// Loads all `.crt` files from `authorized_certs_dir` as trusted client certificate
/// authorities.
///
/// # Errors
///
/// Returns `ConfigError` if any cert file is invalid or TLS configuration fails.
pub fn build_mutual_tls_server_config(
    cert: &CertKeyPair,
    authorized_certs_dir: &Path,
) -> Result<quinn::ServerConfig, ConfigError> {
    let mut root_store = rustls::RootCertStore::empty();

    if authorized_certs_dir.exists() {
        for entry in std::fs::read_dir(authorized_certs_dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.extension().is_some_and(|ext| ext == "crt") {
                let cert_data = std::fs::read(&path)?;
                let cert_der = CertificateDer::from(cert_data);
                root_store.add(cert_der)?;
            }
        }
    }

    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let client_verifier = rustls::server::WebPkiClientVerifier::builder_with_provider(
        Arc::new(root_store),
        Arc::clone(&provider),
    )
    .build()
    .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;
    let rustls_config = rustls::ServerConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .with_client_cert_verifier(client_verifier)
        .with_single_cert(
            vec![cert.cert_der.clone()],
            PrivateKeyDer::Pkcs8(cert.key_der.clone().into()),
        )?;

    let server_config = quinn::ServerConfig::with_crypto(Arc::new(
        quinn::crypto::rustls::QuicServerConfig::try_from(rustls_config)
            .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?,
    ));

    Ok(server_config)
}

/// Builds a quinn `ClientConfig` that trusts a server cert and provides a client cert.
///
/// # Errors
///
/// Returns `ConfigError` if the TLS configuration cannot be built.
pub fn build_client_config_with_cert(
    server_cert_der: &CertificateDer<'static>,
    client_cert: &CertKeyPair,
) -> Result<quinn::ClientConfig, ConfigError> {
    let mut root_store = rustls::RootCertStore::empty();
    root_store.add(server_cert_der.clone())?;

    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let rustls_config = rustls::ClientConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .with_root_certificates(root_store)
        .with_client_auth_cert(
            vec![client_cert.cert_der.clone()],
            PrivateKeyDer::Pkcs8(client_cert.key_der.clone().into()),
        )?;

    let quic_client_config = QuicClientConfig::try_from(rustls_config)
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;

    let mut client_config = quinn::ClientConfig::new(Arc::new(quic_client_config));

    let mut transport = quinn::TransportConfig::default();
    transport.keep_alive_interval(Some(std::time::Duration::from_secs(5)));
    client_config.transport_config(Arc::new(transport));

    Ok(client_config)
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    #[test]
    fn generate_cert_roundtrip() {
        let cert =
            generate_self_signed_cert(&["localhost".to_string(), "127.0.0.1".to_string()]).unwrap();

        assert!(!cert.cert_pem.is_empty());
        assert!(!cert.key_pem.is_empty());
        assert!(!cert.cert_der.is_empty());
        assert!(!cert.key_der.is_empty());
        assert!(cert.cert_pem.contains("BEGIN CERTIFICATE"));
        assert!(cert.key_pem.contains("BEGIN PRIVATE KEY"));
    }

    #[test]
    fn build_server_config_succeeds() {
        let cert = generate_self_signed_cert(&["localhost".to_string()]).unwrap();
        let config = build_server_config(&cert);
        assert!(config.is_ok());
    }

    #[test]
    fn build_client_config_succeeds() {
        let cert = generate_self_signed_cert(&["localhost".to_string()]).unwrap();
        let config = build_client_config(&cert.cert_der);
        assert!(config.is_ok());
    }

    #[test]
    fn paths_resolve() {
        let paths = RosePaths::resolve();
        assert!(paths.config_dir.ends_with("rose"));
        assert!(paths.authorized_certs_dir.ends_with("authorized_certs"));
        assert!(paths.known_hosts_dir.ends_with("known_hosts"));
    }

    #[test]
    fn tofu_first_connection_saves_cert() {
        let dir = std::env::temp_dir().join(format!("rose-tofu-test-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);

        let cert_data = b"fake-cert-der-data";
        let result = tofu_check(&dir, "example.com", cert_data).unwrap();
        assert_eq!(result, TofuResult::FirstConnection);

        // Cert file should exist now
        let cert_path = dir.join("example.com.crt");
        assert!(cert_path.exists());
        assert_eq!(std::fs::read(&cert_path).unwrap(), cert_data);

        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn tofu_verified_on_matching_cert() {
        let dir = std::env::temp_dir().join(format!("rose-tofu-verify-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);

        let cert_data = b"matching-cert";
        // First connection saves it
        tofu_check(&dir, "host1", cert_data).unwrap();
        // Second connection verifies it
        let result = tofu_check(&dir, "host1", cert_data).unwrap();
        assert_eq!(result, TofuResult::Verified);

        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn tofu_mismatch_on_changed_cert() {
        let dir = std::env::temp_dir().join(format!("rose-tofu-mismatch-{}", std::process::id()));
        let _ = std::fs::remove_dir_all(&dir);

        let cert_v1 = b"original-cert";
        let cert_v2 = b"changed-cert";
        tofu_check(&dir, "host2", cert_v1).unwrap();
        let result = tofu_check(&dir, "host2", cert_v2).unwrap();
        assert_eq!(
            result,
            TofuResult::Mismatch {
                cached_path: dir.join("host2.crt"),
            }
        );

        std::fs::remove_dir_all(&dir).unwrap();
    }

    #[test]
    fn build_tofu_client_config_succeeds() {
        let config = build_tofu_client_config();
        assert!(config.is_ok());
    }

    #[test]
    fn build_platform_verified_client_config_succeeds() {
        let config = build_platform_verified_client_config();
        assert!(config.is_ok());
    }

    #[test]
    fn paths_with_base() {
        let paths = RosePaths::with_base(PathBuf::from("/tmp/rose-test"));
        assert_eq!(paths.config_dir, PathBuf::from("/tmp/rose-test"));
        assert_eq!(
            paths.authorized_certs_dir,
            PathBuf::from("/tmp/rose-test/authorized_certs")
        );
        assert_eq!(
            paths.known_hosts_dir,
            PathBuf::from("/tmp/rose-test/known_hosts")
        );
    }
}
