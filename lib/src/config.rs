//! Configuration and certificate management.
//!
//! Manages paths for certificates, known hosts, and authorized certs:
//! - `~/.config/rose/authorized_certs/` — client certs authorized to connect (server side)
//! - `~/.config/rose/known_hosts/` — TOFU server cert cache (client side)
//! - Client and server X.509 certificates generated by `rose keygen`

use std::path::PathBuf;
use std::sync::Arc;

use quinn::crypto::rustls::QuicClientConfig;
use rustls::pki_types::{CertificateDer, PrivateKeyDer};

/// Errors that can occur during configuration or certificate operations.
#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    /// Certificate generation failed.
    #[error("certificate generation failed: {0}")]
    CertGen(#[from] rcgen::Error),
    /// TLS configuration error.
    #[error("TLS configuration error: {0}")]
    Tls(#[from] rustls::Error),
    /// I/O error (reading/writing cert files).
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    /// Quinn crypto configuration error.
    #[error("QUIC crypto configuration error: {0}")]
    QuicCrypto(String),
}

/// A generated certificate and its private key in both PEM and DER formats.
pub struct CertKeyPair {
    /// PEM-encoded certificate.
    pub cert_pem: String,
    /// PEM-encoded private key.
    pub key_pem: String,
    /// DER-encoded certificate.
    pub cert_der: CertificateDer<'static>,
    /// DER-encoded private key.
    pub key_der: Vec<u8>,
}

/// Standard filesystem paths for `RoSE` configuration.
pub struct RosePaths {
    /// Root config directory (e.g. `~/.config/rose/`).
    pub config_dir: PathBuf,
    /// Directory for authorized client certs (server side).
    pub authorized_certs_dir: PathBuf,
    /// Directory for cached server certs (client side, TOFU).
    pub known_hosts_dir: PathBuf,
}

impl RosePaths {
    /// Resolves paths relative to the user's home directory.
    ///
    /// Uses `$HOME/.config/rose/` as the base.
    ///
    /// # Panics
    ///
    /// Panics if the `HOME` environment variable is not set.
    #[must_use]
    pub fn resolve() -> Self {
        let home = std::env::var("HOME").expect("HOME environment variable not set");
        Self::with_base(PathBuf::from(home).join(".config").join("rose"))
    }

    /// Constructs paths with an explicit base directory.
    #[must_use]
    pub fn with_base(base: PathBuf) -> Self {
        Self {
            authorized_certs_dir: base.join("authorized_certs"),
            known_hosts_dir: base.join("known_hosts"),
            config_dir: base,
        }
    }
}

/// Generates a self-signed X.509 certificate for the given Subject Alternative Names.
///
/// # Errors
///
/// Returns `ConfigError::CertGen` if certificate generation fails.
pub fn generate_self_signed_cert(san: &[String]) -> Result<CertKeyPair, ConfigError> {
    let certified_key = rcgen::generate_simple_self_signed(san.to_vec())?;
    let cert_pem = certified_key.cert.pem();
    let key_pem = certified_key.signing_key.serialize_pem();
    let cert_der = certified_key.cert.der().clone();
    let key_der = certified_key.signing_key.serialize_der();

    Ok(CertKeyPair {
        cert_pem,
        key_pem,
        cert_der,
        key_der,
    })
}

/// Builds a quinn `ServerConfig` from a certificate and private key.
///
/// Datagrams are enabled by default in the transport config (quinn default).
///
/// # Errors
///
/// Returns `ConfigError::Tls` if the TLS configuration is invalid.
pub fn build_server_config(cert: &CertKeyPair) -> Result<quinn::ServerConfig, ConfigError> {
    let server_config = quinn::ServerConfig::with_single_cert(
        vec![cert.cert_der.clone()],
        PrivateKeyDer::Pkcs8(cert.key_der.clone().into()),
    )?;
    Ok(server_config)
}

/// Builds a quinn `ClientConfig` that trusts a specific server certificate.
///
/// This is used for the TOFU/pinned-cert model where the client knows the
/// server's certificate in advance.
///
/// # Errors
///
/// Returns `ConfigError` if the TLS configuration cannot be built.
pub fn build_client_config(
    server_cert_der: &CertificateDer<'static>,
) -> Result<quinn::ClientConfig, ConfigError> {
    let mut root_store = rustls::RootCertStore::empty();
    root_store.add(server_cert_der.clone())?;

    let provider = Arc::new(rustls::crypto::ring::default_provider());
    let rustls_config = rustls::ClientConfig::builder_with_provider(provider)
        .with_protocol_versions(&[&rustls::version::TLS13])
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?
        .with_root_certificates(root_store)
        .with_no_client_auth();

    let quic_client_config = QuicClientConfig::try_from(rustls_config)
        .map_err(|e| ConfigError::QuicCrypto(e.to_string()))?;

    let mut client_config = quinn::ClientConfig::new(Arc::new(quic_client_config));

    // Use the same transport config defaults (datagrams enabled)
    let mut transport = quinn::TransportConfig::default();
    transport.keep_alive_interval(Some(std::time::Duration::from_secs(5)));
    client_config.transport_config(Arc::new(transport));

    Ok(client_config)
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    #[test]
    fn generate_cert_roundtrip() {
        let cert =
            generate_self_signed_cert(&["localhost".to_string(), "127.0.0.1".to_string()]).unwrap();

        assert!(!cert.cert_pem.is_empty());
        assert!(!cert.key_pem.is_empty());
        assert!(!cert.cert_der.is_empty());
        assert!(!cert.key_der.is_empty());
        assert!(cert.cert_pem.contains("BEGIN CERTIFICATE"));
        assert!(cert.key_pem.contains("BEGIN PRIVATE KEY"));
    }

    #[test]
    fn build_server_config_succeeds() {
        let cert = generate_self_signed_cert(&["localhost".to_string()]).unwrap();
        let config = build_server_config(&cert);
        assert!(config.is_ok());
    }

    #[test]
    fn build_client_config_succeeds() {
        let cert = generate_self_signed_cert(&["localhost".to_string()]).unwrap();
        let config = build_client_config(&cert.cert_der);
        assert!(config.is_ok());
    }

    #[test]
    fn paths_resolve() {
        let paths = RosePaths::resolve();
        assert!(paths.config_dir.ends_with("rose"));
        assert!(paths.authorized_certs_dir.ends_with("authorized_certs"));
        assert!(paths.known_hosts_dir.ends_with("known_hosts"));
    }

    #[test]
    fn paths_with_base() {
        let paths = RosePaths::with_base(PathBuf::from("/tmp/rose-test"));
        assert_eq!(paths.config_dir, PathBuf::from("/tmp/rose-test"));
        assert_eq!(
            paths.authorized_certs_dir,
            PathBuf::from("/tmp/rose-test/authorized_certs")
        );
        assert_eq!(
            paths.known_hosts_dir,
            PathBuf::from("/tmp/rose-test/known_hosts")
        );
    }
}
